# Merged Design Review — Iteration 1

## codex-executor (gpt-5.3-codex)

### Критические замечания (если есть)

1.
**Суть проблемы:** `VIDEO_CODEC=auto` как новый default меняет внешний контракт: раньше выход практически всегда был `h264` (максимальная совместимость), теперь может стать `h265/av1`, что сломает часть клиентов/плееров. Это backward-incompatible изменение поведения по умолчанию.
**Где:** `app/config.py:29`, design section "`VIDEO_CODEC=auto` (new default)".
**Рекомендация:** либо оставить default `h264` и сделать `auto` opt-in, либо оформить как явный breaking change (версия API/миграционный период/feature flag).

2.
**Суть проблемы:** при `video_codec=auto` на старте проверяется только `h264`, но в рантайме может выбраться `h265/av1`. Для NVIDIA/AMD это может привести к падению encode (энкодер для выбранного кодека отсутствует в конкретной сборке FFmpeg/железе), а runtime fallback заявлен как non-goal.
**Где:** `app/main.py:119` (передача `codec="h264"` в `detect_hw_accel`), `app/hw_accel.py:get_encode_args`.
**Рекомендация:** хранить/проверять матрицу доступных энкодеров для всех auto-кодеков (не только baseline `h264`) и при недоступности выбранного кодека делать детерминированный fallback до запуска job.

3.
**Суть проблемы:** входной `bit_rate` из ffprobe используется как есть; значения `0`, отрицательные или аномально большие могут дать некорректный encode или DoS по ресурсам.
**Где:** план Task 4/Task 2, `VideoAnnotator._get_video_metadata()` + `HWAccelConfig.get_encode_args(..., bitrate=...)`.
**Рекомендация:** ввести валидацию/кламп: принимать только `bitrate > 0` и `<= MAX_VIDEO_BITRATE`, иначе fallback на CRF; покрыть тестами `0`, `-1`, `10^12`.

### Важные замечания

1.
**Суть проблемы:** в документах противоречие по semantics auto-режима: "`VIDEO_CRF` игнорируется" и "fallback всегда CRF 18" vs реализация в плане (использование `self.crf` в auto fallback).
**Где:** design "Behavior/Fallback", "Key decisions #2", plan Task 4 псевдокод.
**Рекомендация:** зафиксировать одно правило (предпочтительно явно: либо всегда `18`, либо `VIDEO_CRF` в fallback) и синхронизировать design/plan/tests.

2.
**Суть проблемы:** еще одно противоречие: в одном месте предлагается `VideoAnnotator(codec="auto")` по умолчанию, в ключевых решениях — оставить `codec="h264"`.
**Где:** design component 4 vs "Key decisions #4".
**Рекомендация:** оставить constructor default `h264` (как в решении), а auto включать только через settings.

3.
**Суть проблемы:** парсинг ffprobe недостаточно защищен от "грязных" данных (`streams` пустой, битый JSON, `r_frame_rate` не `num/den`, `0/0`).
**Где:** `app/video_annotator.py:_get_video_metadata`.
**Рекомендация:** обернуть parse-ошибки в контролируемый `RuntimeError` и добавить тесты на malformed metadata.

4.
**Суть проблемы:** для NVENC/VAAPI "только `-b:v`" может быть формально валидно, но поведение rate control зависит от encoder defaults; unit-тесты проверяют только наличие аргументов, не реальную работоспособность режима.
**Где:** `app/hw_accel.py`, план Task 2, тесты `tests/test_hw_accel.py`.
**Рекомендация:** добавить smoke/integration тест запуска ffmpeg-команды.

5.
**Суть проблемы:** нет теста на wiring startup-логики: что при `video_codec=auto` в `detect_hw_accel` уходит именно baseline codec, а при explicit — исходный codec.
**Где:** `app/main.py` (lifespan), план Task 5.
**Рекомендация:** добавить unit-тест lifespan/инициализации с моками `detect_hw_accel`.

6.
**Суть проблемы:** fallback "unsupported codec + bitrate available -> h264 + CRF18" ухудшает соответствие источнику, хотя bitrate уже известен.
**Где:** design fallback matrix.
**Рекомендация:** рассмотреть `h264 + bitrate` как более близкий к исходнику fallback.

### Незначительные замечания

1. Карта кодеков может быть слишком узкой без нормализации регистра/алиасов. Рекомендация: `codec_name.lower().strip()`.
2. В плане не отражены наблюдаемость и отладка решения в проде. Рекомендация: логировать resolved codec/bitrate.
3. Изменение default без миграционной заметки может создать операционные сюрпризы. Рекомендация: добавить migration note.

### Положительные стороны

1. `VideoMetadata` как dataclass — удачный баланс простоты и расширяемости.
2. Детерминированные правила fallback, unsupported codecs не роняют pipeline.
3. Декомпозиция по компонентам правильная, риски локализуются по слоям.
4. TDD по задачам снижает риск регрессий.

---

## gemini-executor (gemini-3-pro-preview)

### Важные замечания

1. **Нарушение обратной совместимости (Breaking Change)** — Изменение значения по умолчанию VIDEO_CODEC на auto меняет поведение системы для существующих клиентов. Если раньше при загрузке видео H.265 система всегда возвращала H.264 (наиболее совместимый формат), то теперь она вернет H.265. Где: app/config.py, Task 1. Рекомендация: оставить дефолт h264 или явно пометить как breaking change.

2. **Конфликт аргументов кодирования (Bitrate vs CRF)** — Необходимо гарантировать, что при передаче bitrate флаги качества (-crf, -cq, -qp) не добавляются в команду. Где: app/hw_accel.py. Рекомендация: взаимоисключающая логика if/else.

3. **Парсинг битрейта из ffprobe** — Поле bit_rate часто бывает ненадежным: "N/A", отсутствует (MKV), или относится к контейнеру. Где: app/video_annotator.py. Рекомендация: -select_streams v:0, try-except int conversion, fallback CRF 18.

### Незначительные замечания

4. **Буферизация при VBR** — -b:v без -maxrate и -bufsize может давать непредсказуемое поведение с hw энкодерами. Для первой итерации допустимо, TODO в код.

5. **Логирование решений** — Добавить INFO-level logging для auto-codec match decision.

### Положительные стороны

1. Четкая матрица поведения и Fallback Chain.
2. VideoMetadata dataclass улучшает типизацию.
3. _CODEC_NAME_MAP предотвращает command injection.
4. TDD подход.

---

## ccs-executor / GLM (glmt)

### Критические замечания

1. **Потенциальная проблема с поведением по умолчанию** — Изменение VIDEO_CODEC с h264 на auto — breaking change. Рекомендация: добавить раздел "Migration Path".

2. **Отсутствие обработки bit_rate == "0"** — Не рассматривает случай bit_rate == "0" или очень маленького значения. Рекомендация: минимум 1 kbps.

3. **FFmpeg битрейт режим: различия между кодировщиками** — NVENC может требовать -rc vbr, CPU энкодеры — -maxrate/-bufsize. Рекомендация: encoder-specific bitrate args.

### Важные замечания

4. **VideoMetadata vs tuple** — Нужно обновить все тесты для dataclass access.

5. **Codec name mapping не полный** — ffprobe может возвращать avc1, hvc1, hev1. Рекомендация: расширить маппинг.

6. **hw_accel detection при codec="auto"** — Проверяет только h264 encoder, а не av1. Рекомендация: проверять все три кодека.

7. **Логирование выбранного кодека/битрейта** — Нет logging для resolved codec/bitrate. Рекомендация: logger.info().

### Незначительные замечания

8. Отсутствие проверки codec_name — использовать .get("codec_name").
9. Типизация bit_rate: int | None — нужна конвертация с обработкой ошибок.

### Положительные стороны

1. TDD подход с 7 атомарными задачами.
2. Чёткая fallback chain.
3. Non-goals задокументированы.
4. Хорошее покрытие тестами.
5. Атомарные коммиты.
